
#include "incl.h"
#include "structs.h"
#include <math.h>


void    put_pixel(t_image *img, int x, int y, int color)
{
    int index;
    
    index = img->line_length * y + x * (img->bits_per_pixel / 8);
    if (img->endian == 1)        // Most significant (Alpha) byte first
    {
        img->data[index + 0] = (color >> 24);
        img->data[index + 1] = (color >> 16) & 0xFF;
        img->data[index + 2] = (color >> 8) & 0xFF;
        img->data[index + 3] = (color) & 0xFF;
    }
    else if (img->endian == 0)   // Least significant (Blue) byte first
    {
        img->data[index + 0] = (color) & 0xFF;
        img->data[index + 1] = (color >> 8) & 0xFF;
        img->data[index + 2] = (color >> 16) & 0xFF;
        img->data[index + 3] = (color >> 24);
    }
}

static void	put_line_v(t_image *img, t_vec2i *v0, t_vec2i *v1, int color)
{
	float	a;
	float	b;
	int		k;

	if (v0->x < 0 || v0->x > img->width || v0->y < 0 || v0->y > img->height)
		if (v1->x < 0 || v1->x > img->width || v1->y < 0 || v1->y > img->height)
			return ;
	a = (float)(v1->x - v0->x) / (float)(v1->y - v0->y);
	b = -a * (float)v0->y + (float)v0->x;
	k = ft_min(v0->y, v1->y) - 1;
	while (++k <= ft_max(v0->y, v1->y))
		put_pixel(img, a * (float)k + b, k, color);
}

static void	put_line_h(t_image *img, t_vec2i *v0, t_vec2i *v1, int color)
{
	float	a;
	float	b;
	int		k;

	if (v0->x < 0 || v0->x > img->width || v0->y < 0 || v0->y > img->height)
		if (v1->x < 0 || v1->x > img->width || v1->y < 0 || v1->y > img->height)
			return ;
	a = (float)(v1->y - v0->y) / (float)(v1->x - v0->x);
	b = -a * (float)v0->x + (float) v0->y;
	k = ft_min(v0->x, v1->x) - 1;
	while (++k <= ft_max(v0->x, v1->x))
		put_pixel(img, k, a * (float)k + b, color);
}

void	put_line(t_image *img, t_vec2i v0, t_vec2i v1, int color)
{
	if (ft_abs(v1.x - v0.x) > ft_abs(v1.y - v0.y))
		put_line_h(img, &v0, &v1, color);
	else
		put_line_v(img, &v0, &v1, color);
}

void display_f_c(t_world *world, int wall_bottom, int wall_top, int shadow_intensity)
{
    int     i;
    float   distance_ratio;
    int     top_color;
    int     floor_color;

    i = wall_bottom - 1;
    while (++i < world->res.height)
    {
        distance_ratio = (float)(i - (world->res.height / 2)) / ((float)(world->res.height / 2));
        shadow_intensity = 255 * distance_ratio;
        floor_color = (shadow_intensity << 16) | (shadow_intensity << 8) | shadow_intensity;
        put_pixel(&world->backbuffer, world->rays_info.r, i, floor_color);
    }
    i = -1;
    while (++i < wall_top)
    {
        distance_ratio = (float)((world->res.height / 2) - i) / (float)(world->res.height / 2);
        shadow_intensity = 255 * distance_ratio;
        top_color = (shadow_intensity << 16) | (shadow_intensity << 8) | shadow_intensity;
        put_pixel(&world->backbuffer, world->rays_info.r, i, top_color);
    }
}

void render_3d(t_world *world, int px, int py)
{
    int wall_height;
    int wall_top;
    int wall_bottom;
    int wall_color;
    int shadow_intensity;

    world->rays_info.distance = sqrt((world->rays_info.rx - px) * (world->rays_info.rx - px) + (world->rays_info.ry - py) * (world->rays_info.ry - py));
    float corrected_distance = world->rays_info.distance * cos(world->rays_info.ray_angle - world->player.z);
    wall_height = (int)(world->res.height / corrected_distance * (world->res.tile_width / 2.0f));
    wall_top = (world->res.height / 2) - wall_height / 2;
    wall_bottom = (world->res.height / 2) + wall_height / 2;
    if (wall_top < 0)
        wall_top = 0;
    if (wall_bottom > world->res.height)
        wall_bottom = world->res.height;
    shadow_intensity = 255 / (world->rays_info.distance / 30);
    wall_color = (shadow_intensity << 16) | (shadow_intensity << 8) | shadow_intensity;
    put_line(&world->backbuffer, (t_vec2i){world->rays_info.r, wall_top}, (t_vec2i){world->rays_info.r, wall_bottom}, wall_color);
    //draw_textured_wall(world, world->rays_info.mx, world->rays_info.my, wall_top, wall_bottom);
    display_f_c(world, wall_bottom, wall_top, shadow_intensity);
    //put_line(&world->backbuffer, (t_vec2i){px, py}, (t_vec2i){(int)world->rays_info.rx, (int)world->rays_info.ry}, 0xFF0000);
}



void	find_next_hi_vi(t_world *world, float *next_hi, float *next_vi)
{
	if (world->rays_info.ydir != 0)
	{
		if (world->rays_info.ydir < 0)
			*next_hi = (world->rays_info.ry - ((int)(world->rays_info.ry / world->res.tile_height)) * world->res.tile_height + (0.0001f)) / (-world->rays_info.ydir);
		else
			*next_hi = ((int)(world->rays_info.ry / world->res.tile_height + 1) * world->res.tile_height - world->rays_info.ry) / world->rays_info.ydir;
	}
	if (world->rays_info.xdir != 0)
	{
		if (world->rays_info.xdir < 0)
			*next_vi = (world->rays_info.rx - ((int)(world->rays_info.rx / world->res.tile_width)) * world->res.tile_width + (0.0001f)) / (-world->rays_info.xdir);
		else
			*next_vi = (((int)(world->rays_info.rx / world->res.tile_width) + 1) * world->res.tile_width - world->rays_info.rx) / world->rays_info.xdir;
	}
}

int find_next_intersec(t_world *world)
{
	float	nearest_i;
    float	next_hi;
    float	next_vi;

	next_hi = INFINITY;
	next_vi = INFINITY;

	find_next_hi_vi(world, &next_hi, &next_vi);
	if (next_hi == 0)
		next_hi = INFINITY;
	if (next_vi == 0)
		next_vi = INFINITY;
	nearest_i = fmin(next_hi, next_vi);
	if (nearest_i <= 0)
		return (1);
	world->rays_info.rx += world->rays_info.xdir * nearest_i;
	world->rays_info.ry += world->rays_info.ydir * nearest_i;
	return (0);
}

int	check_new_intersec(t_world *world, int mx, int my)
{
	if (mx >= 0 && mx < world->map.width && my >= 0 && my < world->map.height)
	{
		if (world->map.content[my][mx] == MAP_WALL)
		{
			put_line(&world->backbuffer, (t_vec2i){world->rays_info.px, world->rays_info.py}, (t_vec2i){(int)(world->rays_info.rx), (int)(world->rays_info.ry)}, 0xFF0000);
			render_3d(world, world->rays_info.px, world->rays_info.py);
			return (1);
		}
	}
	else
		return (1);
	return (0);
}

float normalize_angle(float angle) {
    while (angle < 0) {
        angle += 2 * PI;
    }
    while (angle >= 2 * PI) {
        angle -= 2 * PI;
    }
    return angle;
}

void raycasting(t_world *world)
{
	int		mx;
	int		my;
	
    world->rays_info.r = world->res.width / 2;
    while (++world->rays_info.r < world->res.width)
    {
		world->rays_info.ray_angle = normalize_angle(world->player.z - (PI / 6) + ((world->rays_info.r - world->res.height) * (PI / 2) / world->res.width));
        world->rays_info.xdir = cos(world->rays_info.ray_angle);
		world->rays_info.ydir = sin(world->rays_info.ray_angle);
        world->rays_info.rx = world->rays_info.px;
        world->rays_info.ry = world->rays_info.py;

        while (1)
        {
            if (find_next_intersec(world))
				break;
            mx = (int)(world->rays_info.rx / world->res.tile_width);
            my = (int)(world->rays_info.ry / world->res.tile_height);
			if (check_new_intersec(world, mx, my))
				break;
        }
    }
}




int move_player2(int keysym, t_world *world)
{
    if (keysym == KEY_UP)
    {
        world->player.x += cos(world->player.z) * 0.1f;
        world->player.y += sin(world->player.z) * 0.1f;
        return (1);
    }
    if (keysym == KEY_LEFT)
    {
        world->player.x += sin(world->player.z) * 0.1f;
        world->player.y -= cos(world->player.z) * 0.1f;
        return (1);
    }
    if (keysym == XK_Left)
    {
        world->player.z -=0.1f;
        return (1);
    }
    if (keysym == XK_Right)
    {
        world->player.z +=0.1f;
        return (1);
    }
    return (0);
}

int move_player(int keysym, t_world *world)
{
    if (keysym == KEY_DOWN)
    {
        world->player.x -= cos(world->player.z) * 0.1f;
        world->player.y -= sin(world->player.z) * 0.1f;
        return (1);
    }
    if (keysym == KEY_RIGHT)
    {
        world->player.x -= sin(world->player.z) * 0.1f;
        world->player.y += cos(world->player.z) * 0.1f;
        return (1);
    }
    return move_player2(keysym, world);
}

int	close_game(t_world *world)
{
    (void)world;
	exit (EXIT_FAILURE);
}

void draw_square(t_image *img, int x, int y, int size, int color)
{
    int i;
    int j;

    j = y - 1;
    while (++j < y + size)
    {
        i = x - 1;
        while (++i < x + size)
            put_pixel(img, i, j, color);
    }
}

void init_img(t_world *world,t_image *img, int width, int heigth)
{
    img->addr = mlx_new_image(world->mlx_ptr, width, heigth);
    img->data = mlx_get_data_addr(img->addr, &img->bits_per_pixel, &img->line_length, &img->endian);
    img->width = width;
    img->height = heigth;
}


int init_minimap(t_world *world)
{
    int i;
    int j;
    int height;
    int width;
    int color;

    height = (world->res.height) / world->map.height;
    width = (world->res.width / 2) / world->map.width;
    init_img(world, &world->minimap, world->res.width, world->res.height);
    j = -1;
    while (++j < (world->map.height))
    {
        i = -1;
        while (++i < (world->map.width))
        {
            if (world->map.content[j][i] == MAP_WALL)
                color = WHITE;
            else if (world->map.content[j][i] == MAP_FLOOR)
                color = GREY;
            else
                color = 0;
            draw_square(&world->minimap, i * width + 1, j * height + 1, width - 2, color);
        }
    }
    return (0);
}

void    cpy_pixel(t_image *dest, t_image *src, int dest_i, int src_i)
{   
    if (dest->endian == src->endian)
    {
        dest->data[dest_i + 0] = src->data[src_i + 0];
        dest->data[dest_i + 1] = src->data[src_i + 1];
        dest->data[dest_i + 2] = src->data[src_i + 2];
        dest->data[dest_i + 3] = src->data[src_i + 3];
    }
    else
    {
        dest->data[dest_i + 0] = src->data[src_i + 3];
        dest->data[dest_i + 1] = src->data[src_i + 2];
        dest->data[dest_i + 2] = src->data[src_i + 1];
        dest->data[dest_i + 3] = src->data[src_i + 0];
    }
}

void    load_texture(t_world *world)
{
    world->map.wall_textures.addr = mlx_xpm_file_to_image(world->mlx_ptr, "textures/mur.xpm", &world->map.wall_textures.width, &world->map.wall_textures.height);
    world->map.wall_textures.data = mlx_get_data_addr(world->map.wall_textures.addr, &world->map.wall_textures.bits_per_pixel, &world->map.wall_textures.line_length, &world->map.wall_textures.endian);
    world->map.wall_textures.size = world->map.wall_textures.line_length / world->map.wall_textures.width;
}

void    cpy_img(t_image *dest, t_image *src, int x, int y)
{
    int i;
    int j;
    int dest_i;
    int src_i;

    j = y - 1;
    while (++j < src->height)
    {
        i = x - 1;
        while (++i < src->line_length)
        {
            dest_i = dest->line_length * (y + j) + (x + i) * (dest->bits_per_pixel / 8);
            src_i = src->line_length * j + i * (src->bits_per_pixel / 8);
            cpy_pixel(dest, src, dest_i, src_i);
        }
    }
}

int render(t_world *world)
{
    world->rays_info.px = world->player.x * ((world->res.width / 2) / world->map.width);
    world->rays_info.py = world->player.y * (world->res.height / world->map.height);
    cpy_img(&world->backbuffer, &world->minimap, 0, 0);
    draw_square(&world->backbuffer, world->rays_info.px - 4, world->rays_info.py - 4, 8, 0x00FF00);
    put_line(&world->backbuffer, (t_vec2i){world->rays_info.px , world->rays_info.py}, (t_vec2i){world->rays_info.px + cos(world->player.z) * 16.0f, world->rays_info.py + sin(world->player.z) * 16.0f}, 0x00FF00);
    raycasting(world);
    mlx_put_image_to_window(world->mlx_ptr, world->win_ptr, world->backbuffer.addr, 0, 0);
    return (0);
}

int main()
{
    t_world world = {
        mlx_init(),
        mlx_new_window(world.mlx_ptr, 1536, 768, "cube3d"),
        {
            {
                { 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
                { 0, 1, 1, 1, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1 },
                { 1, 1, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1 },
                { 1, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1 },
                { 1, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1 },
                { 1, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1 },
                { 1, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 1 },
                { 1, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1 },
                { 1, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1 },
                { 1, 2, 2, 2, 1, 1, 2, 2, 1, 2, 2, 2, 2, 2, 1, 2, 2, 1 },
                { 1, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1 },
                { 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 1 },
                { 1, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1 },
                { 1, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 2, 1 },
                { 1, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1 },
                { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
            },
            18,
            16,
            {0,0,0,0,0,0,0,0},
            0xFF000000,
            0x00FFFF00
        },
        {
            10.5f,
            3.5f,
            4.7f
        },
        {0},
        {0},
        {1536, 768, 0, 0},
        {0}
    };
    world.res.tile_width = (world.res.width / 2) / world.map.width;
    world.res.tile_height = world.res.height / world.map.height;
    init_img(&world, &world.backbuffer, world.res.width, world.res.height);
    init_minimap(&world);
    //load_texture(&world);
    /*mlx_hook(world.win_ptr, KeyPress, KeyPressMask,
			&ft_move_player, s_game);*/
	mlx_hook(world.win_ptr, DestroyNotify, \
		ButtonPressMask, close_game, &world);
    mlx_hook(world.win_ptr, KeyPress, KeyPressMask,
			&move_player, &world);
	mlx_loop_hook(world.mlx_ptr, &render, &world);
    //draw_player(world.player, line_bytes, endian, color, buffer);
    mlx_loop(world.mlx_ptr);
}

